## 目录

*   [题目01：请你用自己的语言介绍 Java 运行时数据区（内存区域）](#题目01请你用自己的语言介绍-java-运行时数据区内存区域)

    *   [堆（Heap）](#堆heap)

    *   [方法区（Method Area）](#方法区method-area)

        *   [1、类信息](#1类信息)

        *   [2、运行时常量池](#2运行时常量池)

        *   [3、即时编译器编译后的代码缓存](#3即时编译器编译后的代码缓存)

    *   [虚拟机栈 （VM Stack）](#虚拟机栈-vm-stack)

    *   [本地方法栈（Native Method Stack）](#本地方法栈native-method-stack)

    *   [程序计数器（Program Counter Register）](#程序计数器program-counter-register)

*   [题目02：描述一个 Java 对象的生命周期](#题目02描述一个-java-对象的生命周期)

*   [题目03：垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？](#题目03垃圾收集算法有哪些垃圾收集器有哪些他们的特点是什么)

    *   [垃圾收集算法：](#垃圾收集算法)

    *   [垃圾收集器](#垃圾收集器)

        *   [Serial收集器](#serial收集器)

        *   [Serial Old收集器](#serial-old收集器)

        *   [ParNew收集器](#parnew收集器)

        *   [Parallel Scavenge](#parallel-scavenge)

        *   [Parallel Old](#parallel-old)

        *   [CMS](#cms)

        *   [G1](#g1)

    *   [垃圾回收器搭配使用](#垃圾回收器搭配使用)

# 作业

# 题目01：请你用自己的语言介绍 Java 运行时数据区（内存区域）

**java**运行时数据区，按照线程使用情况进行以下两种划分：

**1**、线程共享区域，此区域包括堆(**heap**)、方法区（**method area**）

**2**、线程独享区域，此区域包括虚拟机栈（**vm stack**）、本地方法栈（**Native Method Stack**）和程序计数器（**program counter register**）

## 堆（Heap）

堆是虚拟机管理的最大的一块内存区域，该区域设计的目的是存放创建出来的对象实例。

堆区的设计以经验法则“分代假说”为基础：弱分代理论：绝大部分对象都是朝生夕灭的；强分代理论：熬过越多次垃圾回收的对象越难被回收。上述理论体现出以分而治之的思想，对堆划分为新生代和老年代，从而对不同区域采用更合适的垃圾收集策略，提高回收效率。

默认情况下，年轻代占整个堆空间的**1/3**，老年代占整个堆空间的**2/3**。

其中年轻代又划分为**eden**区、**suvivor0**、**suvivor1**，默认情况下上述区域分别占年轻代的**8/10**，**1/10**，**1/10**，可用空间为**eden**区 \*\*+**一个**suvivor**区的大小，“浪费”一个**suvior\*\*区的大小。

一般情况下，创建新对象会默认向年轻代申请地址，当年轻代存储不下的时会触发**YGC**。**YGC**后如果年轻代能够存放的下就存放在**eden**区或**suvivor**区；如果存放不下，则尝试存放到老年代，如果老年代也无法存储，则会触发**FULLGC**，**FULLGC**后可以老年代可以存放的下则放入老年代，如果存放不下则抛出**out of memory**异常。

为了更高效的进行回收，又制定了以下四条对象进入老年代的机制；

**1**、对象分代年龄超过**15**；

**2**、大对象直接进入到老年代。该规则是为了避免大对象在年轻代复制降低效率

**3**、**YGC**后年轻代存活的对象太多，**suvivor**区无法存储，则这些对象会晋升到老年代；

**4**、动态年龄。**YGC**后存活的对象按照年龄从小到大进行占用空间累加，当累加某年轻段对象大小后，空间占比超过**suvivor**区的**50%**（默认值），则该年龄段及以上年龄段全部晋升老年代。

在**JVM**在做**YGC**前还会触发内存担保机制，从而确保有足够的空间能存储下对象，具体规则如下：

年轻代中目前所有对象是否超过老年代剩余空间大小，如果超过则继续判断老年代剩余空间是否小于每次**YGC**后晋升老年代对象的平均大小，如果是则进行**FULLGC**，如果否则进行**YGC**。**YGC**后又有四条具体规则：

**1**、年轻代中的存活对象**suvivor**能够存的下，则放入**suvivor**区；

**2**、年轻代中的存活对象**suvivor**能够存不下，则尝试放入老年代；

**3**、老年代存放不下，则进行**FULLGC**；

**4**、**FULLGC**后存放不下，则抛出**OOM**;

## 方法区（Method Area）

方法区是线程共享区域，用来存储已被虚拟机加载的类型信息、常量、静态变量和即时编译器编译后的代码缓存等。

主要可分为三种类型：

### 1、类信息

类型信息

方法信息

字段信息

静态变量

指向类加载器等引用

指向**Class**对象的引用

方法表

### 2、运行时常量池

运行时常量池从**Class**文件常量池加载而来，包括字面量、符号引用以及符号引用翻译出来的直接内存地址。运行时常量池具备动态性，运行期产生的常量也可以额放在常量池中。

针对运行时常量池中存储的字符串常量，虚拟机又设计出全局唯一的字符串常量池，所有运行时常量池中的字符串常量引用都和字符串常量池中的引用指向同一块内存地址。

### 3、即时编译器编译后的代码缓存

方法区的实现包括两种，一种是永久代和元空间，两者的区别如下：

**1**、**jdk1.8**之前方法区的实现是永久代，**jdk1.8**及之后方法的实现是元空间；

**2**、永久代存储在**jvm**进程分配内存下，使用空间受**jvm**空间限制；元空间存储在物理内存区域，只受物理磁盘大小限制；

**3**、元空间相对于永久代，只存储了类的信息和**JIT**编译后的代码缓存，运行时常量池和静态变量都移到堆中存储；

## 虚拟机栈 （VM Stack）

虚拟机栈是描述线程方法执行的内存模型，与线程生命周期相同。每个方法被执行的过程中，都会同步在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法返回地址。方法的执行都对应着栈帧都入栈和出栈。

对于执行引擎来说，在活动线程中，位与栈顶的方法才是在运行的，位于栈顶的栈帧称为当前栈帧。

## 本地方法栈（Native Method Stack）

本地方法栈和虚拟机栈类似，是支持本地方法执行的

## 程序计数器（Program Counter Register）

程序计数器可以看成是当前线程所执行字节码指令的行号指示器，字节码解释器通过概念这个计数器的值选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复都需要依赖这个计数器。

由于**java**虚拟机多线程是通过线程轮流切换、分配处理器时间片的方式实现的，在同一时刻一个处理器只会执行一个线程的指令，因为为线程切换后程序能恢复正确执行的位置，所以需要该计数器记录程序执行的位置，因为此特性，所以程序计数器为线程独享，个线程间互不影响。

如果执行的是**java**方法，程序计数器存储的是正在执行的字节码指令的内存地址；如果执行的是本地方法，存储的为空

# 题目02：描述一个 Java 对象的生命周期

**java**类加载时机主要包括**4**种：

**1**、遇到**new**、**getstatic**、**putstatic**、**invokestatic**指令时，如果类未初始话会进行初始化；

**2**、使用**java.lang.relfect**包方法对类进行反射调用的时候；

**3**、初始化类的时候如果其父类没有被初始化，会先初始化其父类；

**4**、**java**虚拟机启动的时候，虚拟机会先执行主类的初始化；

通过**new**对象创建的流程如下：

**1**、在执行**new**指令时，会先去常量池是否能定位到类的符号引用；

**2**、如果没有则进行加载，如果定位到符号引用，则判断类是否已经加载，如果未加载则去加载类；

**3**、类加载完成会进行内存空间分配；

**4**、内存空间分配完毕会对内存空间初始话为**0**值；

**5**、对象头设置，包括标记字段（对象的**hash**码、分代年龄，锁标记）、类型指针等；

**6**、执行**init**方法，对象创建完成，进入使用阶段；

上述流程中内存分配方式包括两种：

**1**、使用复制算法的年轻代，和标记 **-** 整理算法的老年代，都可使内存空间连续，可用指针碰撞方式分配内存；

**2**、使用标记 \*\*-**清除算法的**cms\*\*的老年代，由于内存空间不连续，可用空闲列表的方式分配内存；

另外由于内存是线程共享资源，同样也会存在线程安全问题为解决此问题，**jvm**提供的解决方案为：

**1**、使用**CAS**的方式为每个线程预先分配一块内存（称为本地线程分配缓冲，**Thead Local Allocation Buffer TLAB**）线程优先使用该块内存；

**2**、当**TLAB**不足时，会通过**CAS**的方式重新申请内存；

最后当对象无法被**gcroot**s的对象路径关联时，此时对象就会被标记为垃圾，等待垃圾回收器进行回收。

# 题目03：垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

## 垃圾收集算法：

标记 **-** 清除算法

复制算法

标记 **-** 整理算法

## 垃圾收集器

共计有**8**种，分别是：**Serial**、**ParNew**、**Parallel Scavenge**、**CMS**、**Serial Old**、**Parallel Old**、**G1**、**ZGC**

### Serial收集器

用于回收年轻代

串行收集

使用复制算法

收集必须暂停用户线程

在单核**CPU**中使用由于没有线程切换回收效率较高

### Serial Old收集器

用于老年代回收

串行收集

使用标记 **-** 整理算法

使用 **-XX:+UseSerialGC** 默认就会使用上述两种收集器

### ParNew收集器

用于回收年轻代

并行收集

使用复制算法

在单核**CPU**中，如果制定多个线程，由于存在线程切换回收效率不如**Serial**收集器

使用 \*\*-XX:+UseParNewGC**来开启，开启后年轻代并行，老年代串行使用**Serial Old\*\*

### Parallel Scavenge

用于回收年轻代

并行收集

使用复制算法

吞吐量优先

使用 \*\*-XX:+UseParallelGC**开启，开启后年轻代并行，老年代串行**Serial Old\*\*

### Parallel Old

用于回收老年代

并行收集

使用标记 **-** 整理算法

使用 **-XX:+UseParallelOldGC**开启

### CMS

用于回收老年代

并行收集

使用标记 **-** 清除算法

整个回收过程分为**4**个阶段：

初始标记；

会暂停用户线程

找出**GCRoots**直接关联的对象，用时较短

并发标记：

不会暂停用户线程，标记线程和用户线程同时执行

从**GCRoots**开始遍历整个对象树，用时较长

重新标记：

会暂停用户线程

修正并发标记阶段，用户线程产生的新对象

用时比初始标记长，但远低于并发标记阶段用时

并发清除：

不会暂停用户线程

清理掉需要回收对象

根据**CMS**设计规则，可发现**CMS**收集器：

**1**、低延迟：只有初始标记和重新标记阶段会STW

**2**、会产生内存碎片：使用标记-清除算法

### G1

用于整堆回收

基于**region**内存布局，堆空间不再有年轻代和老年代物理划分

并行回收

基于标记 **-** 整理算法，局部基于复制算法，不会产生内存碎片

可根据用户制定垃圾回收时间，此实现通过回收第四步完成，在回收过程中对**region**进行价值和时间排序，再基于用户制定时间制定回收计划

## 垃圾回收器搭配使用

| 年轻代               | 老年代          | 启用参数                                     |
| ----------------- | ------------ | ---------------------------------------- |
| Serial            | Serial Old   | -XX:+UseSerialGC                         |
| Serial            | CMS          | -XX:+UseSerialGC -XX:+UseConcMarkSweepGC |
| ParNew            | Serial Old   | -XX:+UseParNewGC                         |
| ParNew            | CMS          | -XX:+UseParNewGC -XX:+UseConcMarkSweepGC |
| Parallel Scavenge | Serial Old   | -XX:+UseParallelGC                       |
| Parallel Scavenge | Parallel Old | -XX:+UseParallelGC -XX:+UseParallelOldGC |
